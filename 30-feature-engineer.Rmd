---
title: "30-feature-engineer"
output: html_notebook
---
**4. Using best practices, write four functions which add engineered features to the dataset, including a description and rationale. Include a test to determine whether the features are working as intended. **

being graded on the number of FUNCTIONS not the number of columns. so 1 function creating multiple features counts as 1 not the number of features

engineer function 1: abrv_count
will add a column to the df that will count the number of values in a list of characters
```{r}
num_abrv<- function(x,split=", "){
  #takes a vector x and then strsplt on ", " and flattens into a list
  a<-strsplit(x,split)
  b<-lapply(a,length)
  flatten_int(b)
}

abrv_count<- function(df, vars){
  # takes a df and a list of variables that have a list of characters
  df %>% 
    assert(is.character(vars)) %>% 
    mutate_at(vars, list(num_ab=num_abrv)) %>% 
    select(contains("num_ab"), everything())
}
cl_appstore_games %>% 
  abrv_count(c("languages"))

```


engineer function 2: interact_price_lang_num
I am interested in looking at the interaction between price and the number of languages an app has. I created a function that will take the engineered feature num_ab and multiply it by the price

```{r}
interact_price_lang_num<-function(df) {
  df %>% 
  assert(is.double,price) %>% 
  assert(is.integer,num_ab) %>% 
  mutate(interact_pln= price*num_ab)
}

test<- cl_appstore_games %>% 
  abrv_count(c("languages"))

test %>% interact_price_lang_num()

```

engineer function 3:count_by
creates a new column which will return the number of games by the specified column
```{r}
count_n<- function(x){
  length(x)
}

count_by<- function(df, vars,by){
  df %>% 
    group_by({{by}}) %>% 
    mutate_at(vars, list(num=count_n)) %>% 
    ungroup() %>% 
    select(contains("num"),{{by}},everything()) %>% 
    arrange(desc(num))
}

cl_appstore_games %>% 
  count_by(c("average_user_rating"), by=developer)

cl_appstore_games %>% 
  count_by(c("average_user_rating"), by=age_rating)
```


engineer 4 = days since last update (today - current_version_release)
creates a column that is the number of days the current version
```{r}
cl_appstore_games %>% 
  mutate(test= today()-current_version_release_date)

since_l_days<-function(x){
  today()-x
}

days_since_last_v<- function(df, vars){
  df %>% 
  mutate_at(vars,list(day_since_last_v=since_l_days))%>% 
  select(contains("day_since_last_v"), everything())
}
cl_appstore_games %>% 
  days_since_last_v("original_release_date")

```

